== Чудеса ветвления == 
Возможности мгновенного разветвления и слияния - самые уникальные особенности Git.

*Задача*: какие-то причины требуют  переключения процессов. В новой версии внезапно возникает серьезная ошибка. Срок завершения работы над определенным свойством близится к концу. Разработчик, помощь которого очень нужна Вам в работе над ключевым разделом, собирается в отпуск. Итак, Вам нужно срочно бросить все, над чем Вы трудитесь в настоящий момент, и переключиться на совершенно другие дела.

Переключение внимания с одного на другое может серьезно снизить эффективность работы, и чем сложнее переход между процессами, тем больше будет потеря. При централизованном управлении версиями необходимо скачивать вновь разработанную рабочую копию с центрального сервера. Распределенная система предоставляет лучшие возможности, так как позволяет клонировать нужную версию в локальное рабочее место.

Однако клонирование все же предполагает копирование всей рабочей директории, а, значит, всей истории изменений до настоящего момента. Даже при том, что Git позволяет сэкономить средства за счет возможности совместного использования файлов и жестких ссылок, все файлы проекта придется полностью воссоздать в новой рабочей директории.

*Решение*: у Git есть более удобный инструмент для этих целей, который, в отличие от клонирования, сэкономит и время, и дисковое пространство - это *git branch*.

С этой волшебной командой файлы в вашей директории мгновенно изменяются с одной версии на другую. Это изменение позволяет сделать намного больше, чем просто вернуться назад или продвинуться вперед в истории. Ваши файлы могут измениться с последней версии на экспериментальную, с экспериментальной - на опытную, с  опытной - на версию вашего друга и так далее.

=== Кнопка босса ===

Наверняка, вы играли в одну из тех игр, где при нажатии определённой клавиши ("кнопка босса"), игра быстро сворачивается и на экране отображается рабочая таблица или что-нибудь другое? То есть, если в офис зашел начальник, а вы играете в игру, вы должны уметь быстро ее скрыть.

В какой-нибудь директории:

 $ echo "Я хитрее моего босса" > myfile.txt 
 $ git init 
 $ git add .  
 $ git commit -m "Начальный коммит"
 
Мы создали Git-репозиторий, который содержит один текстовый файл с определенным сообщением. Теперь выполните:

 $ git checkout -b boss # вероятно, это последнее изменение
 $ echo "Мой босс меня умнее" > myfile.txt
 $ git commit -a -m "Другой коммит"
 
Похоже на то, как будто мы перезаписали файл и сделали коммит. Но это иллюзия. Наберите:

 $ git checkout master # переключиться на оригинальную версию файла

Вуаля! Текстовый файл восстановлен. И если босс будет рядом, запустите

 $ git checkout boss # перейти на специальную версию для босса

Вы можете переключаться между двумя версиями этого файла так часто, как вам хочется, и делать коммиты в каждый из них независимо.

=== Грязная работа ===

[[branch]]

Допустим, вы работаете над созданием какой-либо функции, и по каким-то причинам необходимо вернуться назад к старой версии и временно загрузить старый код, чтобы посмотреть, как что-либо работало, тогда введите:

 $ git commit -a
 $ git checkout SHA1_HASH

Теперь вы можете добавить везде, где необходимо, временный  черновой код. Можно даже сделать коммит изменений. Когда закончите, выполните:

 $ git checkout master

чтобы вернуться к исходной работе. Заметьте, что любые изменения, не внесенные в коммит, будут перенесены.

А что, если вы все-таки хотели сохранить временные изменения? Пожалуйста:

 $ git checkout -b dirty

а затем сделайте коммит перед тем, как переключитесь на ветвь master. Всякий раз, когда вы захотите вернуться к черновым изменениям, просто выполните:

 $ git checkout dirty

Мы говорили об этой команде ранее, в другой главе, когда обсуждали загрузку старых состояний. Теперь у нас перед глазами полная картина: файлы меняются на нужное состояние, но мы должны оставить ветвь master. Любые коммиты, сделанные с этого момента, направят файлы по другому пути, который может быть назван позже.

Другими словами, после переключения с более старого состояния, Git автоматически направляет вас в новую еще не названную ветвь, которой можно дать имя и сохранить с помощью *git checkout -b*.

=== Быстрые исправления ===

Ваша работа в самом разгаре, когда вдруг выясняется, что нужно все бросить и исправить только что обнаруженную ошибку:

 $ git commit -a
 $ git checkout -b fixes SHA1_HASH

Затем, после того, как вы исправили ошибку:

 $ git commit -a -m "Ошибка исправлена"
 $ git push # в центральный репозиторий
 $ git checkout master

и вернитесь к работе над вашими исходными задачами.

=== Бесперебойный рабочий процесс ===

В некоторых проектах необходимо проверять код до того, как выложить его. Чтобы облегчить задачу другим разработчикам, которые будут проверять ваш код, при внесении значительных изменений, разбивайте измененный проект на 2 или более частей и выкладывайте по одной для проверки.

А что, если вторую часть нельзя записать до того, как первая часть проверена и принята? Во многих системах управления версиями отправить на рассмотрение вторую часть можно только после утверждения первой части.

На самом деле это не совсем правда, но необходимость в таких системах редактировать часть II перед тем, как отправить часть I, связана с трудностями и неудобствами. В Git, ветвление и слияние гораздо безболезненней (говоря техническим языком - это можно сделать быстрее и на локальном уровне). Поэтому, после того, как вы сделали коммит первой части, и направили его для рассмотрения:

 $ git checkout -b part2

Далее, можно изменять вторую часть, не ожидая принятия первой части. После того, как первая часть утверждена и выложена,

 $ git checkout master 
 $ git merge part2 
 $ git branch -d part2 # эта ветка больше не нужна

и вторая часть правок готова к проверке.

Однако не торопитесь! Что, если не все так просто? Что, если в первой части вы сделали ошибку, которую необходимо было исправить до отправки. Запросто! Во-первых, вернитесь в master-ветвь с помощью:

 $ git checkout master

Исправьте изменения в первой части и отправьте на проверку. Если же они не будут приняты, можно просто повторить этот шаг. Вы, вероятно, также захотите произвести слияние исправлений части I с частью II, тогда выполните:

 $ git checkout part2 
 $ git merge master

И теперь – то же самое. После того, как первая часть утверждена и выложена:

 $ git checkout master 
 $ git merge part2
 $ git branch -d part2

и снова, вторая часть готова к проверке.

Вы можете легко использовать этот трюк для любого количества частей.

=== Собрать все в кучу ===

Предположим, вам нравится работать над всеми аспектами проекта в одной и той же ветке. Вы хотите закрыть свой рабочий процесс от других, чтобы все видели ваши коммиты только после того, как они будут хорошо оформлены. Создайте несколько веток:

 $ git checkout -b sanitized
 $ git checkout -b medley

Далее, работайте над чем угодно: исправляйте ошибки, добавляйте новые функции, добавляйте временный код и т.д., при этом постоянно выполняя коммиты. Затем:

 $ git checkout sanitized 
 $ git cherry-pick SHA1_HASH

применит данный коммит для ветви "sanitized". С правильно выбранными элементами вы сможете собрать ветвь, которая будет содержать только проверенный код и соответствующие коммиты, сгруппированные вместе.

=== Управление Ветками ===

Для просмотра списка всех веток наберите:

 $ git branch

Здесь всегда будет ветка с названием "master", с нее вы начинаете работать по умолчанию. Кому-то нравится оставлять ветку "master" нетронутой и создавать новые ветки со своими изменениями.

Опции *-d* и *-m* позволяют удалять и перемещать (переименовывать) ветки.

См. *git help branch*.

Ветка "master" - это полезная традиция. Все считают очевидным то, что ваш репозиторий должен содержать ветку с таким именем, и эта ветка содержит официальную версию проекта. Вы можете переименовать или удалить ветку "master", однако лучше соблюсти всеобщую традицию.

=== Временные Ветки ===

Через какое-то время вы можете обнаружить, что создаете множество временных веток для одной и той краткосрочной цели: нужно сохранить текущее состояние, чтобы была возможность вернуться назад и исправить грубую ошибку или сделать что-то еще.

Это похоже на то, как вы переключаете телевизионные каналы, чтобы посмотреть, что показывают по другим. Но здесь, вместо того, чтобы нажать на пару кнопок на пульте, нужно будет создать, сделать отладку, а затем удалить временные ветки и коммиты. К счастью, в Git есть удобные ярлыки, имитирующие работу дистанционного пульта правления.

 $ git stash

Это сохраняет текущее состояние во временном месте ('копилке') и восстанавливает предыдущее состояние. Ваша директория становиться точно такой, как и была до того, как вы начали редактирование, и вы можете исправить ошибки, загрузить удаленные изменения и прочее. Когда вы хотите вернуться назад в состояние копилки, наберите:

 $ git stash apply # Возможно, понадобится устранить какие-либо конфликты.

Можно создавать несколько копилок, приумножать их и использовать по-разному. Смотрите *git help stash*. Как вы могли догадаться, этот чудесный прием возможен благодаря способности Git создавать закрытые "тайные" ветки.

=== Работайте как вам нравится ===

Такие приложения как http://www.mozilla.com/[Mozilla Firefox] позволяют открывать несколько вкладок, и несколько окон. Переключение вкладок позволяет обозревать разное содержание в одном и том же окне. Ветки в Git подобны вкладкам для вашей рабочей директории. Если продолжить аналогию, клонирование в Git подобно открытию нового окна. Эти две возможности делают работу в Git удобной и приятной для пользователя. 

На более высоком уровне, многие оконные менеджеры Linux поддерживают несколько рабочих столов.

Ветки в Git подобны переключению на другой рабочий стол, а клонирование подобно подключению дополнительно монитора для получения дополнительного рабочего стола.

Другой пример - это утилита http://www.gnu.org/software/screen/[*screen*]. Эта программа позволяет создавать, закрывать и переключаться между множеством терминальных сессий в одном и том же терминале. Вместо открытия нового терминала (операция клонирования), можно использовать этот, запустив *screen* (создать ветвь). На самом деле  у *screen* еще много возможностей, но это уже тема для другой главы.

Наличие возможностей клонирования, ветвления и быстрого локального слияния позволяет вам выбрать комбинировать их так, как удобно и нужно вам. Git позволяет работать именно так, как вам хочется.
