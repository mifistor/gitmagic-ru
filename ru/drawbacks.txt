== Недостатки Git ==

Есть некоторые проблемы Git, которые я спрятал под ковер. Некоторые из них можно легко решить с помощью сценариев и хуков, некоторые требуют реорганизации или пересмотра проекта, и из нескольких оставшихся неприятности, одну придется терпеть. Или еще лучше, взяться за нее и решить!

=== Недостатки SHA1 ===

Со временем, криптографы обнаруживают все больше и больше слабостей в SHA1. Уже сейчас нахождение коллизий хеша не проблема для хорошо финансируемых проектов. Через несколько лет, возможно, даже типичный ПК будет иметь достаточно вычислительной мощности, чтобы самостоятельно скоррумпировать Git репозиторий.

Надеюсь, Git перейдет на лучшую хэш-функцию до того, как дальнейшие исследования разрушат SHA1.

=== Microsoft Windows ===

Git на Microsoft Windows может быть накладным:

- http://cygwin.com/[Cygwin], Linux-среда для Windows, содержит http://cygwin.com/packages/git/[порт Git на Windows].

-http://code.google.com/p/msysgit/[Git на MSys] вариант, требующий минимальной поддержки, хотя для нескольких команд, нужна доработка.

=== Несвязанные файлы ===

Если ваш проект очень большой и содержит много не связанных файлов, которые постоянно изменяются, Git может оказаться в невыгодном положении по сравнению с другими системами, поскольку отдельные файлы не отслеживаются. Git отслеживает изменения всего проекта, такой подход, как правило, полезен.

Решение - разбить проект на части, каждая из которых состоит из связанных файлов. Используйте *git submodule* если вы все еще хотите держать все в одном репозитории.

=== Кто и что редактировал? ===

Некоторые системы контроля версий заставляют вас отметить файл до редактирования. Хотя это особенно раздражает, когда речь идет о работе с центральным сервером, этот способ имеет два преимущества:

  1. Diff'ы быстры, потому что только отмеченные файлы должны быть изучены.

  2. Можно обнаружить, кто еще работает с этим файлом, спросив центральный сервер, кто отметил его для редактирования.

При наличии соответствующих сценариев, вы можете добиться того же с Git. Это требует сотрудничества со стороны других программистов, которые должны выполнять сценарии при редактировании файла.

=== История файлов ===

Поскольку Git записывает изменения всего проекта, то чтобы восстановить историю одного файла требуется больше работы, чем в системах управления версиями, которые позволяют отслеживать отдельные файлы.

Потери, как правило, небольшие, а также стоит иметь в виду, что другие операции являются невероятно эффективными. Например, `git checkout` быстрее, чем `cp -a`, и вся дельта проекта сжимаются лучше, чем коллекции на основе дельт файлов.

=== Начальное Клонирование ===

Создание клона репозитория дороже обычного чекаута в другие системы управления версиями, особенно когда существует большая история.

Первоначальная цена окупается в долгосрочной перспективе, так как большинство операций, затем будут происходить быстро и в автономном режиме. Однако в некоторых ситуациях может быть предпочтительным создание мелких клонов с опцией `--depth`. Это намного быстрее, но в результате снижается функциональность клона.

=== Изменчивые Проекты ===

Git был написан, чтобы быть быстрым по отношению к небольшим изменениям. Люди делают небольшие исправления от версии к версии. Однострочные исправление здесь, новые функции там, исправленные комментарии, и так далее. Но если ваши файлы, радикально отличаются в следующей ревизии, то на каждой фиксации ваша история обязательно увеличивается на размер всего вашего проекта.

Не существует системы управления версиями, которая может решить эту проблему, но пользователи Git пострадают больше, поскольку клонируется вся история.

Причины, почему эти изменения бывают настолько велики, должны быть изучены. Возможно, формат файла должен быть изменен. Малые изменения должны быть причиной малых изменений в самих файлах.

Или, возможно, то, что вам было нужно, это базы данных или система резервного копирования или архивы, а не система контроля версий. Например, контроль версий может быть плохо приспособлен для управления периодически получаемыми с веб-камеры фотографиями.

Если файлы действительно должны постоянно изменяться, и они действительно должны версионироваться, возможно использовать Git централизованным образом. Можно создать мелкие клоны, с небольшой или без истории проекта. Конечно, многие инструменты Git будут недоступны, и исправления должны быть представлены в виде патчей. Вероятно, это хорошо, поскольку неясно, почему кто-то хочет вести историю дико неустойчивых файлов.

Другим примером является проект, зависимый от прошивки, которая принимает форму огромного бинарного файла. История этой микропрограммы неинтересна для пользователей, и обновления сжимаются плохо, так версии микропрограммы могут излишне увеличить размера хранилища.

В этом случае исходный код должен храниться в хранилище Git, а бинарные файлы - отдельно. Чтобы сделать жизнь проще, можно было бы распространять скрипт, который использует Git чтобы клонировать код и Rsync или мелкий клон Git для прошивки.

=== Глобальный счетчик ===

Некоторые централизованные системы контроля версий, используют положительные числа, которые возрастают, когда происходит новый коммит. Git идентифицирует изменения их хешем, который лучше во многих обстоятельствах.

Но некоторым люди нравится эти числа вокруг. К счастью, легко написать скрипт, который при каждом обновлении центрального Git репозитория увеличивал целое число, возможно, в теге, и связывал его с хешем последним коммитом.

Каждый клон может поддерживать такой счетчик, но это, вероятно, будет бесполезным, поскольку только центральный репозиторий имеет значение для всех.

=== Пустые подкаталоги ===

Пустые подкаталоги не могут быть отслежены. Создайте пустой файл, чтобы обойти эту проблему.

В этом виноват не замысел Git, а его текущая реализация. Если повезет, и пользователи Git уделят больше внимания этой функции, возможно, она будет реализована.

=== Первоначальный коммит ===

Обычный ученый в области информатики считает от 0, а не от 1. К сожалению, Git с его коммитами не придерживается этой конвенции. Многие команды плохо работают до первого коммита. Кроме того, некоторые частные случаи должны быть обработаны специально, такие, как rebase веток с различными начальными коммитами.

Git'у желательно определение нулевого коммита: как только будет построен репозиторий, HEAD будет установлен в строку, состоящую из 20 нулевых байтов. Этот специальный коммит представляет собой пустое дерево, предшествующее всему в Git репозитории.

Если затем запустить *git log*, например, то вместо выхода с фатальной ошибкой он будет показывать пользователю, что коммиты еще не были сделаны. Аналогично для других инструментов.

Каждый первоначальный коммит - неявный потомок этого нулевого коммита. Например, несвязанный с какой-либо веткой rebase в целом будет применен к нему. В настоящее время применяются все, кроме первоначального коммита, в результате чего получается конфликт слияния. Один из способов заключается в использовании `git checkout` после `git commit -C` первоначального коммита, тогда rebase пройдет нормально.

К сожалению, в худшем случае, если несколько ветвей с различными начальными коммитами сливаются, то rebase результата требует значительного ручного вмешательства.
