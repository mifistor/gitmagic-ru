== Недостатки Git ==

Есть некоторые проблемы Git, которые я спрятал под сукно. Некоторые из них можно легко решить с помощью сценариев и хуков, некоторые требуют реорганизации или пересмотра проекта, и из нескольких оставшихся неприятностей одну придется терпеть. Или, еще лучше, взяться за нее и решить!

=== Недостатки SHA1 ===

Со временем криптографы обнаруживают все больше уязвимостей SHA1. Уже сейчас нахождение коллизий хэшей является возможным для хорошо финансируемых организаций. Возможно, скоро даже обыкновенный ПК будет иметь достаточную вычислительную мощность, чтобы незаметно повредить Git репозиторий.

Надеюсь, Git мигрирует к лучшей хэш-функции до того, как дальнейшие исследования изживут SHA1.

=== Microsoft Windows ===

Git на Microsoft Windows может быть накладным:

- http://cygwin.com/[Cygwin], Linux-среда для Windows, содержит http://cygwin.com/packages/git/[порт Git на Windows].

-http://code.google.com/p/msysgit/[Git на MSys] альтернативный вариант, требующий минимальной рантайм поддержки, хотя для нескольких команд нужна доработка.

=== Несвязанные файлы ===

Если ваш проект очень большой и содержит много несвязанных файлов, которые постоянно изменяются, Git может оказаться в невыгодном положении по сравнению с другими системами, поскольку отдельные файлы не отслеживаются. Git отслеживает изменения всего проекта, что обычно предпочтительнее.

Решение - разбить проект на части, каждая из которых состоит из связанных файлов. Используйте *git submodule* если вы все еще хотите держать все в одном репозитории.

=== Кто и что редактировал? ===

Некоторые системы контроля версий заставляют вас отметить файл до редактирования. Хотя это особенно раздражает, когда речь идет о работе с центральным сервером, этот способ имеет два преимущества:

  1. Diff'ы быстры, потому что только отмеченные файлы должны быть изучены.

  2. Можно обнаружить, кто еще работает с этим файлом, спросив центральный сервер, кто отметил его для редактирования.

При наличии соответствующих сценариев вы можете добиться того же с Git. Это требует сотрудничества со стороны других программистов, которые должны выполнять сценарии при редактировании файла.

=== История файлов ===

Поскольку Git записывает изменения всего проекта, то для того чтобы восстановить историю одного файла требуется больше работы, чем в системах управления версиями, которые позволяют отслеживать отдельные файлы.

Потери, как правило, небольшие, а также стоит иметь в виду, что другие операции являются невероятно эффективными. Например, `git checkout` быстрее, чем `cp -a`, и вся дельта проекта сжимается лучше, чем коллекция на основе дельт файлов.

=== Начальное клонирование ===

Создание клона репозитория дороже обычного чекаута в другие системы управления версиями, особенно когда существует большая история.

Первоначальная цена окупается в долгосрочной перспективе, так как большинство операций затем будут происходить быстро и в автономном режиме. Однако в некоторых ситуациях может быть предпочтительным создание мелких клонов с опцией `--depth`. Это намного быстрее, но в результате снижается функциональность клона.

=== Изменчивые проекты ===

Git был написан, чтобы быть быстрым по отношению к небольшим изменениям. Люди делают небольшие исправления от версии к версии. Однострочное исправление здесь, новые функции там, исправленные комментарии и так далее. Но если ваши файлы радикально отличаются в следующей ревизии, то на каждой фиксации ваша история обязательно увеличивается на размер всего вашего проекта.

Не существует системы управления версиями, которая может решить эту проблему, но пользователи Git страдают больше, поскольку клонируется вся история.

Причины, почему эти изменения бывают настолько велики, должны быть изучены. Возможно, формат файла должен быть изменен. Малые изменения должны быть причиной малых изменений в самих файлах.

Или, возможно, в каком-то случае лучше использовать базы данных, системы резервного копирования или архивы, а не систему контроля версий. Например, контроль версий может быть плохо приспособлен для управления фотографиями, периодически получаемыми с веб-камеры.

Если файлы действительно должны постоянно изменяться и версионироваться, можно использовать Git централизованным образом. Можно создать мелкие клоны, с небольшой или без истории проекта. Конечно, многие инструменты Git будут недоступны, и исправления должны быть представлены в виде патчей. Вероятно, это хорошо, потому как неясно, зачем кому-то вести историю постоянно изменяющихся файлов.

Другим примером является проект, зависимый от прошивки, которая принимает форму огромного бинарного файла. История этой микропрограммы неинтересна для пользователей, обновления сжимаются плохо, поэтому версии микропрограммы могут излишне увеличить размера хранилища.

В этом случае исходный код должен храниться в хранилище Git, а бинарные файлы - отдельно. Чтобы сделать жизнь проще, можно было бы распространять скрипт, который используется Git для клонирования кода, а также Rsync или мелкий клон Git для прошивки.

=== Глобальный счетчик ===

Некоторые централизованные системы контроля версий используют положительные числа, которые возрастают, когда происходит новый коммит. Git идентифицирует их хэшем, который лучше по многим причинам.

Но некоторым людям нравится работать с этими целыми. К счастью, легко написать сценарии, чтобы при каждом обновлении центральный репозиторий Git увеличивал целое число, возможно, в теге, и связывал его с хэшем последнего коммита.

Каждый клон может поддерживать такой счетчик, но это, вероятно, будет бесполезным, поскольку важны только центральный репозиторий и его счётчик.

=== Пустые подкаталоги ===

Пустые подкаталоги не могут быть отслежены. Создайте пустой файл, чтобы обойти эту проблему.

В этом виноват не дизайн Git, а его текущая реализация. Если повезет, и пользователи Git уделят больше внимания этой функции, возможно, она будет реализована.

=== Первоначальный коммит ===

Среднестатистический ученый в области информатики считает с 0, а не с 1. К сожалению, Git с его коммитами не присоединяется к этой конвенции. Многие команды плохо работают до первого коммита. Кроме того, некоторые частные случаи должны быть обработаны специально, такие как rebase веток с различными начальными коммитами.

Git'у желательно определение нулевого совершения: как только будет построено хранилище, HEAD будет установлен в строку, состоящую из 20 нулевых байтов. Этот специальный коммит представляет собой пустое дерево без родителей, предшествовавшее всему в Git репозитории.

После этого запуск *git log*, например, будет показывать пользователю, что коммиты еще не были сделаны, вместо выхода с фатальной ошибкой. Аналогично для других инструментов.

Каждая первоначальная фиксация - неявный потомок этого нулевого коммита. Например, несвязанный с какой-либо веткой rebase в целом будет привит на эту цель. В настоящее время применяются все, кроме первоначального, коммиты, в результате чего получается конфликт слияния. Один из способов решения проблемы заключается в использовании `git checkout` после `git commit -C` первоначального коммита, тогда rebase пройдет нормально.

К сожалению, в худшем случае, если несколько ветвей с различными начальными коммитами сливаются, rebase результата требует значительного ручного вмешательства.
